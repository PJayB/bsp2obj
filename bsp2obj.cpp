// bsp2obj.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "BSP.h"

#include <vector>
#include <iostream>
#include <fstream>
#include <string>

#include <assert.h>

using namespace std;

#define VERBOSE( x )	

bool ReadWholeFile( const char* file, vector<uint8_t>& data )
{
	FILE* f;
	fopen_s( &f, file, "rb" );
	if ( !f )
		return false;

	fseek( f, 0, SEEK_END );
	data.resize( ftell( f ) );
	fseek( f, 0, SEEK_SET );

	size_t totalRead = 0;
	while ( !feof( f ) && totalRead < data.size() )
	{
		size_t r = fread( &data[totalRead], 1, data.size() - totalRead, f );
		if ( !r )
			break;
		totalRead += r;
	}

	fclose(f);

	data.resize( totalRead );

	return true;
}

std::string SafeF( float f )
{
	char tmp[128];
	sprintf_s(
		tmp, sizeof(tmp),
		"%f", f );
	return tmp;
}

int _tmain(int argc, _TCHAR* argv[])
{
	vector<uint8_t> bspData;

	if ( argc < 3 )
	{
		VERBOSE( cout << "Usage: bsp2obj <input.bsp> <output.obj>" << endl );
		return 1;
	}

	cout << "BSP2OBJ " << argv[1] << " ... ";

	if ( !ReadWholeFile( argv[1], bspData ) )
	{
		cout << "FAILED" << endl; 
		return 1;
	}

	VERBOSE( cout << "OK! " << bspData.size() << " bytes read." << endl );
	VERBOSE( cout << "Parsing ... " );

	BSP* bsp = BSP::Create( &bspData[0], bspData.size() );
	if ( !bsp )
	{
		cout << "FAILED" << endl;
		return 1;
	}

	VERBOSE( cout << "OK!" << endl );
	VERBOSE( cout << "Summary:" << endl );

	VERBOSE( cout << " * " << bsp->Materials.size() << " Materials" << endl );
	VERBOSE( cout << " * " << bsp->Planes.size() << " Planes" << endl );
	VERBOSE( cout << " * " << bsp->Nodes.size() << " Nodes" << endl );
	VERBOSE( cout << " * " << bsp->Leaves.size() << " Leaves" << endl );
	VERBOSE( cout << " * " << bsp->LeafFaces.size() << " Leaf Faces" << endl );
	VERBOSE( cout << " * " << bsp->LeafBrushes.size() << " Leaf Brushes" << endl );
	VERBOSE( cout << " * " << bsp->Models.size() << " Models" << endl );
	VERBOSE( cout << " * " << bsp->Brushes.size() << " Brushes" << endl );
	VERBOSE( cout << " * " << bsp->BrushSides.size() << " Brush Sides" << endl );
	VERBOSE( cout << " * " << bsp->Vertices.size() << " Vertices" << endl );
	VERBOSE( cout << " * " << bsp->Indices.size() << " Indices" << endl );
	VERBOSE( cout << " * " << bsp->Fogs.size() << " Fogs" << endl );
	VERBOSE( cout << " * " << bsp->Faces.size() << " Faces" << endl );
	VERBOSE( cout << " * " << bsp->LightMaps.size() << " Light Maps" << endl );
	VERBOSE( cout << " * " << bsp->LightVolumes.size() << " Light Volumes" << endl );
	VERBOSE( cout << " * " << bsp->NumClusters << " Clusters" << endl );

	VERBOSE( cout << "Saving to " << argv[2] < " ... " );
	
	// Open the output file
	ofstream obj;
	obj.open( argv[2] );
	if ( !obj.is_open() )
	{
		cout << "FAILED to write!" << endl;
		delete bsp;
		return 1;
	}

	// Open the material definition file
	std::string mtlFile = argv[2];
	mtlFile = mtlFile.substr( 0, mtlFile.find_last_of('.') );
	mtlFile += ".mtl";
	ofstream mtl;
	mtl.open( mtlFile.c_str() );
	if ( !mtl.is_open() )
	{
		cout << "FAILED to open material file: " << mtlFile << endl;
		delete bsp;
		return 1;
	}

	obj.unsetf(ostream::floatfield);
	mtl.unsetf(ostream::floatfield);

	obj << "# Generated by BSP2OBJ" << endl;
	obj << "# Source file: " << argv[1] << endl;
	obj << "# BSP2OBJ was created by Peter J. B. Lewis, 2013" << endl;
	obj << "# If your OBJ doesn't load, please email the " << endl;
	obj << "# dedicated support email: bsp2obj@gibbering.net" << endl;
	obj << endl;

	obj << "# Begin Vertex Positions for " << bsp->Vertices.size() << " vertices." << endl;
	for ( auto& v : bsp->Vertices )
	{
		obj << "v " << SafeF( v.Position[0] )
			<<  " " << SafeF( v.Position[1] )
			<<  " " << SafeF( v.Position[2]	)
			<< endl;
	}
	obj << "# End Vertex Positions" << endl << endl;

	obj << "# Begin Vertex UVs for " << bsp->Vertices.size() << " vertices." << endl;
	for ( auto& v : bsp->Vertices )
	{
		obj << "vt " << SafeF( v.TexCoord[0] )
			<<   " " << SafeF( v.TexCoord[1] )
			<<   " " << SafeF( v.TexCoord[2] )
			<< endl;
	}
	obj << "# End Vertex UVs" << endl << endl;

	obj << "# Begin Vertex Normals for " << bsp->Vertices.size() << " vertices." << endl;
	for ( auto& v : bsp->Vertices )
	{
		obj << "vn " << SafeF( v.Normal[0] )
			<<   " " << SafeF( v.Normal[1] )
			<<   " " << SafeF( v.Normal[2] )
			<< endl;
	}
	obj << "# End Vertex Normals" << endl << endl;

	obj << "# Begin Face Definitions for " << bsp->Faces.size() << " faces." << endl;
	for ( auto& f : bsp->Faces )
	{
        if ( f.NumIndices == 0 )
            continue;

		const uint32_t* indices = &bsp->Indices[f.StartIndex];

		const BSP::Texture& tex = bsp->Materials[f.TextureID];
		obj << "# Surface " << tex.Name << endl;

		int numFaces = f.NumIndices / 3;
		for ( int a = 0; a < numFaces; ++a )
		{
			size_t i = 1 + f.StartVertexIndex + indices[a * 3 + 0];
			size_t j = 1 + f.StartVertexIndex + indices[a * 3 + 1];
			size_t k = 1 + f.StartVertexIndex + indices[a * 3 + 2];
			obj << "f "	<< i << "/" << i << "/" << i << " "
						<< j << "/" << j << "/" << j << " "
						<< k << "/" << k << "/" << k << " "
						<< endl;
		}

		obj << endl;
	}
	obj << "# End Face Definitions" << endl << endl;

	cout << "OK!" << endl;

	mtl.close();
	obj.close();

	delete bsp;

	return 0;
}

