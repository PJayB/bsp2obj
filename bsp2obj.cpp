// bsp2obj.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "BSP.h"
#include "VFS/VFS.h"
#include "VFS/FileUtils.h"

#include <direct.h> // TODO remove me

#include <vector>
#include <iostream>
#include <fstream>
#include <string>
#include <map>

#include <assert.h>

using namespace std;

#define VERBOSE( x )	


typedef std::map<std::string, std::string> StringMap;


string SafeF( float f )
{
	char tmp[128];
	sprintf_s(
		tmp, sizeof(tmp),
		"%f", f );
	return tmp;
}

string SafeMaterial( string mtl )
{
    for ( size_t i = 0; i < mtl.size(); ++i )
    {
        if ( mtl[i] == '/' )
            mtl[i] = '_';
    }
    return move( mtl );
}


std::string RemoveBase(const std::string& oldBase, std::string path)
{
	if ( strncmp(path.c_str(), oldBase.c_str(), oldBase.size()) == 0 )
		path = path.substr(oldBase.size());
	return path;
}

std::string Rebase(const std::string& oldBase, const std::string& newBase, std::string path)
{
	if ( strncmp(path.c_str(), oldBase.c_str(), oldBase.size()) == 0 )
		path = path.substr(oldBase.size());
	return newBase + path;
}


const int SF_NODRAW = 0x00200000;


bool DumpObj( const char* filename, const char* mtlFilename, const BSP* bsp )
{
	// Open the output file
	ofstream obj;
	obj.open( filename );
	if ( !obj.is_open() )
	{
		cout << "FAILED to write!" << endl;
		return false;
	}

	obj.unsetf(ostream::floatfield);

	obj << "# Generated by BSP2OBJ" << endl;
	obj << "# BSP2OBJ was created by Peter J. B. Lewis, 2013" << endl;
	obj << "# If your OBJ doesn't load, please email the " << endl;
	obj << "# dedicated support email: bsp2obj@gibbering.net" << endl;
	obj << endl;

    string localMtlFN = mtlFilename;
    string::size_type slashPos = localMtlFN.find('/');
    if ( slashPos != string::npos )
    {
        localMtlFN = localMtlFN.substr(slashPos + 1);
    }
    obj << "mtllib " << localMtlFN.c_str() << endl << endl;

	obj << "# Begin Vertex Positions for " << bsp->Vertices.size() << " vertices." << endl;
	for ( auto& v : bsp->Vertices )
	{
		obj << "v " << SafeF( v.Position[0] )
			<<  " " << SafeF( v.Position[2] )
			<<  " " << SafeF(-v.Position[1] )
			<< endl;
	}
	obj << "# End Vertex Positions" << endl << endl;

	obj << "# Begin Vertex UVs for " << bsp->Vertices.size() << " vertices." << endl;
	for ( auto& v : bsp->Vertices )
	{
		obj << "vt " << SafeF( v.TexCoord[0] )
			<<   " " << SafeF( v.TexCoord[1] )
			<<   " " << SafeF( v.TexCoord[2] )
			<< endl;
	}
	obj << "# End Vertex UVs" << endl << endl;

	obj << "# Begin Vertex Normals for " << bsp->Vertices.size() << " vertices." << endl;
	for ( auto& v : bsp->Vertices )
	{
		obj << "vn " << SafeF( v.Normal[0] )
			<<   " " << SafeF( v.Normal[1] )
			<<   " " << SafeF( v.Normal[2] )
			<< endl;
	}
	obj << "# End Vertex Normals" << endl << endl;

	obj << "# Begin Face Definitions for " << bsp->Faces.size() << " faces." << endl;
    int surfCount = 0;
	for ( auto& f : bsp->Faces )
	{
        if ( f.NumIndices == 0 )
            continue;

        // Skip non-solid surfs
		const BSP::Texture& tex = bsp->Materials[f.TextureID];
        if ( tex.Flags & SF_NODRAW )
            continue;

        obj << "usemtl " << SafeMaterial( tex.Name ) << endl;
        obj << "o surf" << surfCount << endl;

		const uint32_t* indices = &bsp->Indices[f.StartIndex];
        
        surfCount++;

		int numFaces = f.NumIndices / 3;
		for ( int a = 0; a < numFaces; ++a )
		{
			size_t i = 1 + f.StartVertexIndex + indices[a * 3 + 0];
			size_t j = 1 + f.StartVertexIndex + indices[a * 3 + 1];
			size_t k = 1 + f.StartVertexIndex + indices[a * 3 + 2];
			obj << "f "	<< i << "/" << i << "/" << i << " "
						<< k << "/" << k << "/" << k << " "
						<< j << "/" << j << "/" << j << " "
						<< endl;
		}

		obj << endl;
	}
	obj << "# End Face Definitions" << endl << endl;

	VERBOSE( cout << "OK!" << endl );

	obj.close();

    return true;
}

bool DumpMtl( const char* filename, const BSP* bsp, const StringMap& textureRemap )
{
	ofstream mtl;
	mtl.open( filename );
	if ( !mtl.is_open() )
	{
		cout << "FAILED to open material file: " << filename << endl;
		return false;
	}

	mtl.unsetf(ostream::floatfield);

	mtl << "# Generated by BSP2OBJ" << endl;
	mtl << "# BSP2OBJ was created by Peter J. B. Lewis, 2013" << endl;
	mtl << "# If your OBJ doesn't load, please email the " << endl;
	mtl << "# dedicated support email: bsp2obj@gibbering.net" << endl;
	mtl << endl;

    for ( auto& tex : bsp->Materials )
    {
        // Skip non-solid surfs
        if ( tex.Flags & SF_NODRAW )
            continue;

        mtl << "newmtl " << SafeMaterial( tex.Name ) << endl;
        mtl << "Ka 1 1 1" << endl;
        mtl << "Kd 1 1 1" << endl;
        mtl << "Ks 0 0 0" << endl;
        mtl << "Ns 10" << endl;

		StringMap::const_iterator m = textureRemap.find(tex.Name);
		if ( m != end(textureRemap) )
			mtl << "map_Kd " << m->second << endl;
		else
			mtl << "map_Kd " << tex.Name << endl;

        mtl << endl;
    }

	mtl.close();

    return true;
}

void RemapTextures( const BSP* bsp, StringMap& remapping )
{
	StringMap textures;

	for (auto& t : bsp->Materials)
	{
		string name = VFS::MakeFullyQualifiedFileName( t.Name );
		textures[name] = t.Name;
	}

	VERBOSE( cout << "Found " << textures.size() << " unique materials to process." << endl ); 

	VFS::EnumerateFiles(
		"/",
		[&] (const char* f) 
		{
			// remove the extension
			std::string base = VFS::ReplaceExtension(f, "");
			
			StringMap::const_iterator i = textures.find(base);
			if ( i != end(textures) )
			{
				// We found a matching texture! Remap it
				remapping[i->second] = RemoveBase( 
					VFS::GetRootDirectory(),
					f );
			}
		});
}

bool ParseBSP( const char* bspFile, const char* objFile, VFS::FileListing& texturesToExport )
{
	vector<uint8_t> bspData;

	cout << "Converting " << bspFile << " ... ";

	if ( !VFS::ReadWholeBinaryFile( bspFile, bspData ) )
	{
		cout << "FAILED" << endl; 
		return false;
	}

	VERBOSE( cout << "OK! " << bspData.size() << " bytes read." << endl );
	VERBOSE( cout << "Parsing ... " );

	BSP* bsp = BSP::Create( &bspData[0], bspData.size() );
	if ( !bsp )
	{
		cout << "FAILED" << endl;
		return false;
	}

	VERBOSE( cout << "OK!" << endl );
	VERBOSE( cout << "Summary:" << endl );

	VERBOSE( cout << " * " << bsp->Materials.size() << " Materials" << endl );
	VERBOSE( cout << " * " << bsp->Planes.size() << " Planes" << endl );
	VERBOSE( cout << " * " << bsp->Nodes.size() << " Nodes" << endl );
	VERBOSE( cout << " * " << bsp->Leaves.size() << " Leaves" << endl );
	VERBOSE( cout << " * " << bsp->LeafFaces.size() << " Leaf Faces" << endl );
	VERBOSE( cout << " * " << bsp->LeafBrushes.size() << " Leaf Brushes" << endl );
	VERBOSE( cout << " * " << bsp->Models.size() << " Models" << endl );
	VERBOSE( cout << " * " << bsp->Brushes.size() << " Brushes" << endl );
	VERBOSE( cout << " * " << bsp->BrushSides.size() << " Brush Sides" << endl );
	VERBOSE( cout << " * " << bsp->Vertices.size() << " Vertices" << endl );
	VERBOSE( cout << " * " << bsp->Indices.size() << " Indices" << endl );
	VERBOSE( cout << " * " << bsp->Fogs.size() << " Fogs" << endl );
	VERBOSE( cout << " * " << bsp->Faces.size() << " Faces" << endl );
	VERBOSE( cout << " * " << bsp->LightMaps.size() << " Light Maps" << endl );
	VERBOSE( cout << " * " << bsp->LightVolumes.size() << " Light Volumes" << endl );
	VERBOSE( cout << " * " << bsp->NumClusters << " Clusters" << endl );

	VERBOSE( cout << "Saving to " << objFile < " ... " );

	// Make sure the output directory is present
	string objPath = VFS::BasePath( objFile );
	VFS::MakeNestedDirectories( objPath.c_str() );

	// Collect textures and find their real identities
	StringMap textureRemap;
	RemapTextures( bsp, textureRemap );

	for (auto& i : textureRemap)
	{
		// Add it to the export list
		texturesToExport.insert(i.second);
	}

	// Open the material definition file
	string mtlFile = VFS::ReplaceExtension( objFile, ".mtl" );

    int result = 1;
    if ( DumpObj( objFile, mtlFile.c_str(), bsp ) )
    {
	    if ( DumpMtl( mtlFile.c_str(), bsp, textureRemap ) )
            result = 0;
    }

    delete bsp;

    if ( result == 0 )
        cout << "OK!" << endl;

	return true;
}

void MountPakFiles()
{
	// Enumerate the pak files
	VFS::FileListing pakFiles;

	VFS::EnumerateFiles( 
		"/",
		[&] (const char* f) 
		{
			if ( strstr(f, ".pk3") != nullptr )
				pakFiles.insert( f );
		}, 
		true );

	for ( auto& f : pakFiles )
	{
		cout << "Mounting " << f << endl;

		VFS::AddZip( f.c_str() );
	}
}

bool ExportTexture(const char* source, const char* destination)
{
	std::vector<uint8_t> texData;
	if (!VFS::ReadWholeBinaryFile(source, texData))
	{
		return false;
	}

	// Make sure the output directory is present
	VFS::MakeNestedDirectories( VFS::BasePath( destination ).c_str() );

	ofstream out(destination, ios::out | ios::binary);
	if (!out.is_open())
	{
		return false;
	}

	out.write((const char*)&texData[0], texData.size());
	out.close();

	return true;
}

int _tmain(int argc, _TCHAR* argv[])
{
	if ( argc < 2 )
		VFS::SetRootDirectory( _getcwd( NULL, 0 ) );
	else
		VFS::SetRootDirectory( argv[1] );

	MountPakFiles();

	int totalFiles = 0;
	VFS::FileListing bspFiles;
	VFS::EnumerateFiles(
		"/",
		[&] (const char* f) 
		{
			if ( strstr(f, ".bsp") != nullptr )
				bspFiles.insert( f );
			totalFiles++;
		});

	cout << "Found " << bspFiles.size() << " BSP files in " << totalFiles << " game files." << endl;

	std::string basePath = VFS::GetRootDirectory();
	std::string outputPath = "output/";

	_mkdir( outputPath.c_str() );

	VFS::FileListing texturesToExport;

	for (auto& bspFile : bspFiles)
	{
		string objFile = outputPath + VFS::BaseName( bspFile ) + ".obj";

		if ( !ParseBSP( bspFile.c_str(), objFile.c_str(), texturesToExport ) )
			return 1;
	}

	cout << "Exporting " << texturesToExport.size() << " textures..." << endl;

	for (auto& t : texturesToExport)
	{
		string dest = Rebase(basePath, outputPath, t);
		ExportTexture(t.c_str(), dest.c_str());
	}

	return 0;
}

